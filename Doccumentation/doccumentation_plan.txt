#Prompt


The aim is to provide detailed implementation guidelines and ensure a clear separation of concerns between documents. The architecture.txt file is a source of truth for the architecture, think through all the details for this file then implement them, This has to be done extremely carefully, determine what the best implementation would look like by thinking really hard about it. After generating a rough draft in the same format as the architecture.txt file create questions about implementation to ask me to clarify, give answers to each question I can fill out with pros and cons for each answer, then use these answers to improve the implementation



# CKOS Documentation Implementation Plan

This document outlines the key sections and content planned for each supporting documentation file for the CKOS project. The aim is to provide detailed implementation guidelines and ensure a clear separation of concerns between documents.

## I. Core System Design Documents

### 1. `Doccumentation/UI_System_Design.txt`
    - **Focus:** Implementation of `Display_Task` and its interaction with `ApplicationLogic_Task` for UI.
    - **Key Sections:**
        - **`Display_Task` Architecture:**
            - Internal state management (current screen, active animations).
            - Message queue processing logic for commands from `ApplicationLogic_Task`.
            - U8g2 library integration: Initialization, BSP wrapper usage for drawing.
            - Framebuffer management: Structure, allocation, drawing order, layering.
        - **Screen/View Implementation Guide:**
            - Structure for screen handler functions within `Display_Task`.
            - Receiving and processing screen-specific data from `ApplicationLogic_Task`.
            - Managing UI element state within screen handlers.
        - **Reusable UI Component Implementation (within `Display_Task`):**
            - Detailed implementation guide for each component (e.g., PIN Entry Pad, Time Selector, Menu System):
                - Drawing logic using U8g2 via BSP.
                - Internal state management (e.g., current selection, input buffer).
                - Responding to translated input events.
                - Application of theme parameters.
        - **Animation Engine Implementation:**
            - Data structures for animation definitions (sprite sheets, frame data, timing).
            - Frame-by-frame update logic.
            - RTOS timer integration for animation pacing.
            - Mechanics of starting/stopping/modifying animations based on commands.
        - **Partial Update Mechanism Implementation:**
            - Algorithm for identifying changed screen regions (dirty rectangle tracking or frame comparison).
            - Interface with `bsp_display_update_region` for efficient display updates.
        - **Asset Integration (Implementation Details):**
            - Accessing and rendering compiled C arrays (XBMs for images, U8g2 fonts) via BSP.
            - Memory considerations for UI assets.
        - **Theme Engine Implementation:**
            - Data structure design for themes (colors, fonts, styles).
            - Logic for applying theme parameters during drawing operations.

### 2. `Doccumentation/Lock_System_Design.txt`
    - **Focus:** Core logic of all locking mechanisms, primarily within `ApplicationLogic_Task`.
    - **Key Sections:**
        - **Core Lock Data Structures:**
            - C `struct` definitions for storing lock configurations (type, duration, PINs, agent/game settings).
            - Mapping of these structures to persistent storage (EEPROM emulation).
        - **Time Tracking Implementation:**
            - Algorithms for calculating remaining time, total accumulated lock time per type, current session time.
            - RTC interaction for UTC time and unlock alarms.
            - Logic for time accrual during "Cleaning/Breaks" (pausing/resuming).
        - **Lock Type Specific Implementation (within `ApplicationLogic_Task`):**
            - **Agent Lock:**
                - Storing agent selection.
                - Interface points for triggering Agent System interactions.
            - **Custom Lock:**
                - Duration validation logic (min/max, multi-confirmation).
                - Integration logic for game outcomes modifying lock parameters.
            - **Keyholder Lock (Basic Mode):**
                - PIN setting algorithm and validation logic.
                - Secure PIN storage considerations (if any obfuscation/hashing).
            - **Keyholder Lock (Remote Mode):**
                - Device-side pairing process logic.
                - Identicon generation/retrieval method.
                - Unlock key processing: index management, window validation, single-use enforcement.
                - Cleaning key processing: temporary unlock flow, duration enforcement.
                - Config key processing: parameter update logic and validation.
        - **"Cleaning/Breaks" Feature Implementation:**
            - State management for active breaks.
            - Time limit enforcement mechanism.
            - Implementation of penalties (mood effects, session time reset).
        - **Verification Screen Data Logic:**
            - Gathering and formatting data for the third-party verification screen.

### 3. `Doccumentation/Agent_System_Design.txt`
    - **Focus:** Agent "AI," content management, and interaction logic within `ApplicationLogic_Task`.
    - **Key Sections:**
        - **Agent Data Structures:**
            - `struct` definitions for agent profiles (personality traits, image asset references, dialog IDs).
            - Representation and storage of mood levels.
            - Tracking interaction history with agents.
        - **Mood Engine Implementation:**
            - Algorithm detailing how user interactions and game outcomes influence mood levels.
            - Impact of total accumulated lock time on baseline mood or behavior.
        - **Dialog System Implementation:**
            - Storage format for dialog text (e.g., lookup tables, string arrays).
            - Logic for selecting dialogs based on agent, mood, context, and history.
            - Implementation of any dynamic elements in dialogs (e.g., variable substitution).
        - **Agent Decision Logic Implementation:**
            - How agents determine available options or responses.
            - Implementation of any probabilistic elements in agent behavior.
        - **Interface with `ApplicationLogic_Task` State Machine:**
            - How agent interaction modes are entered and exited.
            - Handling events specific to the agent system.

### 4. `Doccumentation/Game_System_Design.txt`
    - **Focus:** Implementation of mini-games and their integration with `ApplicationLogic_Task` and `Display_Task`.
    - **Key Sections (repeated for each planned game):**
        - **Game [Name] - Core Logic Implementation (within `ApplicationLogic_Task`):**
            - Game-specific state machine or flow control.
            - Rules engine implementation.
            - Processing validated game inputs.
            - Algorithm for determining game outcomes and their effects (e.g., on lock time).
            - Storing/retrieving game state if applicable.
        - **Game [Name] - Display Interaction Implementation:**
            - Defining data structures passed to `Display_Task` for rendering game state.
            - Specifying commands for game-specific animations or UI elements.
        - **Game [Name] - Configuration Implementation:**
            - How game parameters are configured in "Custom Lock" mode and stored.

### 5. `Doccumentation/Hardware_Service_Layer_Design.txt`
    - **Focus:** Implementation details of `HardwareService_Task` and its sub-modules (HLM, Sensors, Storage).
    - **Key Sections:**
        - **`HardwareService_Task` Architecture:**
            - Internal state management and operational modes.
            - Message queue processing for requests from `ApplicationLogic_Task`.
            - Task notification mechanisms for sending events/responses.
        - **Hardware Lock Manager (HLM) Implementation:**
            - Memory wire actuation sequence:
                - PWM control logic (using `bsp_pwm_set_precise` and timing).
                - Temperature compensation algorithm details (if applicable at this level).
                - Latch and ejector sensor monitoring logic during actuation.
                - Detailed timing and retry strategy implementation.
            - Processing door/lever switch states for lock/unlock determination.
        - **Sensor Management Implementation:**
            *   Button debouncing algorithm implementation details.
            *   Logic for generating button press/release events for `ApplicationLogic_Task`.
            *   Implementation of ADC readings for battery voltage and temperature (if handled directly here).
        - **Storage Operations Implementation:**
            *   Wrapper logic around BSP functions for Flash R/W and EEPROM emulation.
            *   Data integrity check implementations (e.g., CRC calculations).
        - **Low-Level Power Control Functions (executed by `HardwareService_Task`):**
            *   Implementation details of functions that command the BSP to change MCU power modes.
            *   Interfacing with `ckos_power_insomnia_level` for critical hardware operations.

### 6. `Doccumentation/Power_Management_System_Design.txt`
    - **Focus:** System-wide power management strategy, coordination, and power-saving techniques.
    - **Key Sections:**
        - **System Power State Machine Implementation:**
            - Logic for determining the target system power state based on activity.
            - Coordination of peripheral power states (shutdown/clock gating) via `HardwareService_Task` -> BSP.
        - **RTOS Idle Hook (`vPortSuppressTicksAndSleep`) Implementation Details:**
            - Logic for checking `ckos_power_insomnia_level`.
            - Selecting appropriate low-power MCU mode (STOP2 vs. light sleep).
            - Calling `HardwareService_Task` or BSP for MCU mode entry/exit.
            - Pre-sleep and post-sleep peripheral configuration management.
        - **Battery Management Logic (within `ApplicationLogic_Task` or dedicated module):**
            - Interpreting battery voltage readings from `HardwareService_Task`.
            - Algorithm for triggering low battery warnings and UI updates.
            - Logic for handling critically low battery states (e.g., initiating deep sleep, preventing unlock).
            - Monitoring charger IC status and providing UI feedback.
        - **`ckos_power_insomnia_enter/exit` Usage and Implementation:**
            - Guidelines for usage by various modules.
            - Atomic increment/decrement implementation.
        - **Tickless Idle Implementation Details:**
            - RTC alarm setup for timed wake-ups from low-power modes.
            - Considerations for LSE drift and its impact on scheduling accuracy.

## II. Interface and API Documentation

### 7. `Doccumentation/Inter_Task_Communication_ICD.txt`
    - **Focus:** API contracts between tasks; the definitive source for message/notification formats.
    - **Key Sections:**
        - **General IPC Principles:**
            - Data copying vs. pointer passing rules for messages.
            - Timeout policies for queue operations.
        - **Queue: `ApplicationLogic_Task` -> `Display_Task` (`display_task_queue_handle`):**
            - For each `DisplayCommandID` (e.g., `CMD_ACTIVATE_SCREEN`, `CMD_UPDATE_TEXT_ELEMENT`):
                - C `struct` definition for the message payload.
                - Detailed description of each field in the payload (type, purpose, valid values).
                - Expected behavior and processing by `Display_Task`.
        - **Queue: `ApplicationLogic_Task` -> `HardwareService_Task`:**
            - For each request type (e.g., `REQ_UNLOCK`, `REQ_READ_SENSORS`):
                - C `struct` definition for the message payload.
                - Field descriptions, purpose, and expected processing by `HardwareService_Task`.
        - **Task Notifications: `HardwareService_Task` -> `ApplicationLogic_Task`:**
            - Enumeration of all event types/notification values (e.g., `EVT_BUTTON_PRESS`).
            - Precise meaning and data packed into the 32-bit notification value for each event.
        - **Task Notifications: ISRs -> Tasks (e.g., to `HardwareService_Task` or `ApplicationLogic_Task`):**
            - `vTaskNotifyGiveFromISR()` / `xTaskNotifyFromISR()` usage patterns.
            - Definition of notification values and their meanings in this context.
        - **System Component Internal APIs (If any direct calls cross module boundaries within the *same* task context):**
            - C Function signatures, parameter details (type, purpose), return types, and brief functional description. (To be used sparingly).

### 8. `Doccumentation/BSP_API_Reference.txt`
    - **Focus:** Exhaustive API reference for all functions in `bsp_drivers.h/.c`.
    - **Key Sections (template repeated for *each* BSP function):**
        - **Function Signature.**
        - **Purpose:** Clear, concise description of what the function does.
        - **Parameters:**
            - For each parameter: Name, C type, direction (in/out/in-out), detailed description of purpose and valid range/values.
        - **Return Value:**
            - C type, description of possible return values, including error codes or status indicators.
        - **Preconditions:** Conditions that *must* be true before calling the function.
        - **Postconditions:** State of the system or relevant hardware after successful execution.
        - **Notes:**
            - Underlying STM32Cube HAL/LL drivers used.
            - Critical timing considerations or constraints.
            - Reentrancy or thread-safety notes.
            - Power consumption implications.
        - **Example Usage Snippet.**

## III. Development Process and Guidelines

### 9. `Doccumentation/Build_Flash_Debug_Guide.txt`
    - **Focus:** Practical "how-to" guide for developers for the entire development lifecycle.
    - **Key Sections:**
        - **Development Environment Setup:**
            - STM32CubeIDE: Installation, workspace configuration, recommended settings.
            - Required external tools: Python (for scripts), version control client (Git).
            - Initial project checkout and import procedures.
        - **Build Process Walkthrough:**
            - Step-by-step guide from clean checkout to generating firmware binary.
            - Executing asset conversion scripts (`convert_pbm_to_c_array.py`): command line usage, inputs, expected outputs.
            - Executing state table generation scripts (`generate_state_table.py`): usage, inputs, outputs.
            - Building the project with STM32CubeIDE (Debug vs. Release configurations).
            - Understanding build outputs: `.elf`, `.bin`, `.map` files.
        - **Project Configuration Files (`App/Config/` directory):**
            - Explanation of each configuration header file and key macros within them.
            - How to enable/disable features or change system parameters via these files.
        - **Firmware Flashing Procedures:**
            - Using STM32CubeProgrammer (GUI and command-line interface).
            - Step-by-step DFU mode entry on the target hardware.
            - Troubleshooting common flashing issues.
        - **Debugging Techniques and Best Practices:**
            - STM32CubeIDE Debugger: Effective use of breakpoints, watch expressions, call stack, register view, memory view.
            - FreeRTOS Awareness Plugin: Inspecting task states, stack usage, queues, semaphores, timers.
            - SWV/ITM Data Console: Setup for `printf` redirection, interpreting trace data.
            - MPU Fault Debugging: Analyzing fault registers (`CFSR`, `MFAR`, `MMFSR`), identifying causes of memory protection faults.
            - FreeRTOS Debugging Aids: `configASSERT`, stack overflow detection methods, `uxTaskGetStackHighWaterMark`.
            - Effective use of the on-device `LOG()` macro and severity levels.

### 10. `Doccumentation/Testing_Strategy_and_QA.txt`
    - **Focus:** Guidelines and procedures for writing, running tests, and ensuring overall code quality.
    - **Key Sections:**
        - **Unit Testing (Unity & FFF):**
            - Setting up the test environment for individual C modules.
            - Writing effective test cases using Unity assertions and test structures.
            - Comprehensive guide to using FFF (Fake Function Framework) for mocking dependencies:
                - Mocking BSP functions.
                - Mocking other application module functions.
                - Verifying call history and arguments.
            - Organizing test files and test suites.
            - Running unit tests and interpreting results.
        - **Integration Testing Strategy:**
            - Approaches for testing interactions between coupled modules or tasks (e.g., host-based simulation, partial hardware setups).
            - Defining integration test boundaries and focus areas (e.g., message passing integrity, state transition sequences).
        - **Hardware-in-the-Loop (HIL) Testing:**
            - HIL test environment setup and required equipment.
            - Strategy for developing automated test scripts for HIL (if applicable).
            - Key end-to-end scenarios to validate on actual hardware.
        - **Static Analysis Integration and Policy:**
            - Configuring and running STM32CubeIDE's MISRA C/C++ checker and Clang-Tidy.
            - Guidelines for interpreting static analysis reports and addressing violations.
            - Policy for handling warnings/errors (e.g., zero critical issues before merge).
            - CI integration for automated static analysis.
        - **Code Coverage:**
            - Tools and procedures for generating code coverage reports (e.g., gcov/lcov, IDE plugins).
            - Analyzing coverage reports to identify untested code paths.
            - Project code coverage targets and strategies for improvement.
        - **Test Case Design Principles:**
            - Applying techniques like boundary value analysis, equivalence partitioning, and error guessing.
            - Designing tests for state transitions and critical paths.

### 11. `Doccumentation/Asset_Pipeline_Guide.txt`
    - **Focus:** Complete lifecycle of UI and other assets, from source files to integration in firmware.
    - **Key Sections:**
        - **Image Assets (PBM):**
            - PBM (P1 ASCII type) format specification and constraints.
            - Recommended tools for creating and editing PBM images.
            - `convert_pbm_to_c_array.py` script:
                - Detailed command-line options and usage.
                - Input PBM file requirements (dimensions, color depth implications for monochrome).
                - Explanation of the output XBM C array format.
                - Naming conventions for source PBM files and generated C arrays (e.g., `agent_happy.pbm` -> `g_xbm_agent_happy`).
            - Directory structure for source PBMs (`Assets_Src/Images/`).
            - Integration of generated C arrays into the firmware build (`App/Display/Assets/`).
        - **Font Assets:**
            - Supported source font formats (e.g., BDF).
            - Conversion process to U8g2 C array format (tools, steps, U8g2 font format specifics).
            - Storing source font files (`Assets_Src/Fonts/`).
            - Integrating generated font C arrays into the firmware (`App/Display/Assets/`).
        - **Workflow for Adding or Updating Assets:**
            - Step-by-step process from new asset creation/modification to inclusion in the build.
            - When and how to re-run conversion scripts.
            - Verifying asset integration.
        - **Memory Considerations for Assets:**
            - Impact of asset size on Flash memory usage.
            - Strategies for optimizing asset sizes if needed.

### 12. `Doccumentation/Contribution_and_Coding_Standards.txt`
    - **Focus:** Rules, guidelines, and best practices for collaborative team development.
    - **Key Sections:**
        - **Version Control (Git) Strategy:**
            - Branching model (e.g., Gitflow-like: `main`, `develop`, `feature/xxx`, `bugfix/xxx`, `release/xxx`).
            - Commit message conventions (e.g., Conventional Commits standard for clarity and changelog generation).
            - Pull Request (PR) / Merge Request (MR) process: creation, review guidelines, merging criteria.
        - **Detailed Coding Style Guide:**
            - Naming Conventions (reiterate and expand: Types=UpperCamelCase, functions=snake_case, variables=snake_case, macros=UPPER_SNAKE_CASE, enums=UpperCamelCase, enum members=UPPER_SNAKE_CASE).
            - Formatting: Indentation (e.g., 4 spaces), brace style (e.g., K&R or Allman), max line length (e.g., 100-120 chars).
            - Comments: Doxygen-style for functions, modules, and files. Inline comments (`//`) for clarifying complex code. What to comment and what not to comment.
            - `#include` order and best practices.
            - `const` correctness usage.
            - Error handling patterns (return codes, `configASSERT`).
            - Preprocessor macro usage guidelines (avoid complex macros if functions suffice).
            - Consistent use of `stdint.h` types (e.g., `uint8_t`, `int32_t`).
            - File structure (header guards, organization of content within .c/.h files).
        - **Code Review Checklist and Process:**
            - Key aspects to check during review: adherence to standards, logic correctness, test coverage, performance, security, documentation, clarity.
            - Constructive feedback guidelines.
            - Roles and responsibilities in the review process.
        - **Proposing and Implementing Changes/New Features:**
            - Use of issue tracking system (if any).
            - Design discussion and approval process before major implementation.
        - **Static Analysis Compliance:**
            - Expectation of resolving static analysis warnings/errors before submitting code for review.

### 13. `Doccumentation/Memory_Layout_and_Management.txt`
    - **Focus:** Detailed breakdown of how Flash and RAM are organized and utilized, including MPU specifics.
    - **Key Sections:**
        - **Flash Memory Map:**
            - Bootloader region (STM32 DFU or custom).
            - Vector table location and size.
            - `.text` section (program code): typical size, key contents.
            - `.rodata` section (constants, string literals, compiled XBM image assets, font assets).
            - EEPROM emulation area (X-CUBE-EEP): size, location, purpose.
            - Linker script (`.ld` file) overview: how it defines these sections and their placement.
        - **RAM Memory Map:**
            - `.data` section (initialized static/global variables).
            - `.bss` section (uninitialized static/global variables).
            - Heap area(s) used by FreeRTOS (details based on `heap_x.c` choice, e.g., `heap_5.c` regions).
            - Task Stacks: Specific locations, sizes, and guard bands for `HardwareService_Task`, `ApplicationLogic_Task`, `Display_Task`.
            - Static Slab Allocation Arenas (e.g., `display_buffer_arena`): exact addresses, sizes, alignment.
            - Display Framebuffer: location, size (if managed separately from general slab arenas).
        - **Memory Pool (`memory_pool.c/.h`) Implementation Details:**
            - Internal data structures for pool and block management.
            - Algorithms for `memory_pool_alloc()` and `memory_pool_free()`.
            - Alignment considerations for allocated blocks.
            - Statistics tracking (`memory_pool_get_stats`).
        - **MPU Configuration for Robustness (Detailed Implementation):**
            - For each configured MPU Region:
                - Base address, size, and subregion disable mask (if used).
                - Access permissions (e.g., Privileged RW / Unprivileged NA).
                - Execute Never (XN) attribute settings.
                - Shareable, Cacheable, Bufferable attributes.
                - Precise purpose (e.g., Stack Guard for Task X, NULL Pointer Protection Region 0, Peripheral Access Control).
            - How MPU regions are configured at startup and by the FreeRTOS MPU port (if applicable).
            - `MemManage_Handler` implementation: logging fault information (registers like `MFSR`, `MMFAR`, `CFSR`), recovery strategies (e.g., system reset, error state).
        - **Analyzing and Optimizing Memory Usage:**
            - Techniques using linker map files to identify large consumers.
            - Using STM32CubeIDE memory analysis tools.
            - FreeRTOS stack usage monitoring (`uxTaskGetStackHighWaterMark`).
            - Compiler flags for size optimization (`-Os`).
            - Data structure packing and alignment strategies.

### 14. `Doccumentation/State_Machine_Reference.txt`
    - **Focus:** The definitive, possibly auto-generated, reference for the main state machine within `ApplicationLogic_Task`.
    - **Key Sections:**
        - **Introduction:**
            - Brief overview of the table-driven finite state machine (FSM) approach used.
            - How to interpret the state transition tables or diagrams presented.
            - Link to the CSV/JSON source file if the table is auto-generated.
        - **State Definitions:**
            - Enumeration or comprehensive list of all defined states.
            - For each state:
                - Symbolic name (e.g., `MENU_STATE`, `LOCK_ACTIVE_STATE`).
                - Brief description of its purpose or the system condition it represents.
        - **Event Definitions:**
            - Enumeration or comprehensive list of all defined events that can trigger transitions.
            - For each event:
                - Symbolic name (e.g., `EVENT_BUTTON_A_PRESS`, `EVENT_DOOR_CLOSED`).
                - Brief description of what triggers the event.
        - **State Transition Table(s):**
            - The core content, presented in a clear tabular format.
            - Columns: `Current State`, `Triggering Event`, `Guard Condition Function (if any)`, `Action Handler Function`, `Next State`.
            - If auto-generated from `generate_state_table.py` using a CSV/JSON source, this section will embed or directly represent that output.
            - Must be meticulously maintained or reliably generated to reflect the actual implementation.
        - **Handler Function Descriptions:**
            - A list of all unique action handler function pointers referenced in the state transition table.
            - For each handler function:
                - Function prototype (signature).
                - Brief description of the primary actions performed by the handler (e.g., "Initiates unlock sequence via HardwareService_Task," "Updates display with remaining time").
        - **Guard Condition Function Descriptions:**
            - A list of all unique guard condition function pointers.
            - For each guard function:
                - Function prototype.
                - Brief description of the condition it checks (e.g., "Returns true if battery level is sufficient for unlock").
